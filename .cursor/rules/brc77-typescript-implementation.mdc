---
description: brc77 typescript implementation
globs: 
alwaysApply: false
---
// sign

// @ts-nocheck
import PublicKey from '../primitives/PublicKey.js'
import PrivateKey from '../primitives/PrivateKey.js'
import Signature from '../primitives/Signature.js'
import Curve from '../primitives/Curve.js'
import Random from '../primitives/Random.js'
import { toBase64, toArray, Reader, toHex } from '../primitives/utils.js'

const VERSION = '42423301'

/**
 * Signs a message from one party to be verified by another, or for verification by anyone, using the BRC-77 message signing protocol.
 * @param message The message to sign
 * @param signer The private key of the message signer
 * @param [verifier] The public key of the person who can verify the message. If not provided, anyone will be able to verify the message signature.
 *
 * @returns The message signature.
 */
export const sign = (
  message: number[],
  signer: PrivateKey,
  verifier?: PublicKey
): number[] => {
  const recipientAnyone = typeof verifier !== 'object'
  if (recipientAnyone) {
    const curve = new Curve()
    const anyone = new PrivateKey(1)
    const anyonePoint = curve.g.mul(anyone)
    verifier = new PublicKey(anyonePoint.x, anyonePoint.y)
  }
  const keyID = Random(32)
  const keyIDBase64 = toBase64(keyID)
  const invoiceNumber = `2-message signing-${keyIDBase64}`
  const signingKey = signer.deriveChild(verifier, invoiceNumber)
  const signature = signingKey.sign(message).toDER()
  const senderPublicKey = signer.toPublicKey().encode(true)
  const version = toArray(VERSION, 'hex')
  return [
    ...version,
    ...senderPublicKey,
    ...(recipientAnyone ? [0] : verifier.encode(true)),
    ...keyID,
    ...signature
  ]
}

/**
 * Verifies a message using the BRC-77 message signing protocol.
 * @param message The message to verify.
 * @param sig The message signature to be verified.
 * @param [recipient] The private key of the message verifier. This can be omitted if the message is verifiable by anyone.
 *
 * @returns True if the message is verified.
 */
export const verify = (
  message: number[],
  sig: number[],
  recipient?: PrivateKey
): boolean => {
  const reader = new Reader(sig)
  const messageVersion = toHex(reader.read(4))
  if (messageVersion !== VERSION) {
    throw new Error(
      `Message version mismatch: Expected ${VERSION}, received ${messageVersion}`
    )
  }
  const signer = PublicKey.fromString(toHex(reader.read(33)))
  const [verifierFirst] = reader.read(1)
  if (verifierFirst === 0) {
    recipient = new PrivateKey(1)
  } else {
    const verifierRest = reader.read(32)
    const verifierDER = toHex([verifierFirst, ...verifierRest])
    if (typeof recipient !== 'object') {
      throw new Error(
        `This signature can only be verified with knowledge of a specific private key. The associated public key is: ${verifierDER}`
      )
    }
    const recipientDER = recipient.toPublicKey().encode(true, 'hex') as string
    if (verifierDER !== recipientDER) {
      throw new Error(
        `The recipient public key is ${recipientDER} but the signature requres the recipient to have public key ${verifierDER}`
      )
    }
  }
  const keyID = toBase64(reader.read(32))
  const signatureDER = toHex(reader.read(reader.bin.length - reader.pos))
  const signature = Signature.fromDER(signatureDER, 'hex')
  const invoiceNumber = `2-message signing-${keyID}`
  const signingKey = signer.deriveChild(recipient, invoiceNumber)
  const verified = signingKey.verify(message, signature)
  return verified
}


// encrypt

import PublicKey from '../primitives/PublicKey.js'
import PrivateKey from '../primitives/PrivateKey.js'
import SymmetricKey from '../primitives/SymmetricKey.js'
import Random from '../primitives/Random.js'
import { toBase64, toArray, Reader, toHex } from '../primitives/utils.js'

const VERSION = '42421033'

/**
 * Encrypts a message from one party to another using the BRC-78 message encryption protocol.
 * @param message The message to encrypt
 * @param sender The private key of the sender
 * @param recipient The public key of the recipient
 *
 * @returns The encrypted message
 */
export const encrypt = (
  message: number[],
  sender: PrivateKey,
  recipient: PublicKey
): number[] => {
  const keyID = Random(32)
  const keyIDBase64 = toBase64(keyID)
  const invoiceNumber = `2-message encryption-${keyIDBase64}`
  const signingPriv = sender.deriveChild(recipient, invoiceNumber)
  const recipientPub = recipient.deriveChild(sender, invoiceNumber)
  const sharedSecret = signingPriv.deriveSharedSecret(recipientPub)
  const symmetricKey = new SymmetricKey(sharedSecret.encode(true).slice(1))
  const encrypted = symmetricKey.encrypt(message) as number[]
  const senderPublicKey = sender.toPublicKey().encode(true)
  const version = toArray(VERSION, 'hex')
  return [
    ...version,
    ...senderPublicKey,
    ...recipient.encode(true),
    ...keyID,
    ...encrypted
  ]
}

/**
 * Decrypts a message from one party to another using the BRC-78 message encryption protocol.
 * @param message The message to decrypt
 * @param sender The private key of the recipient
 *
 * @returns The decrypted message
 */
export const decrypt = (message: number[], recipient: PrivateKey): number[] => {
  const reader = new Reader(message)
  const messageVersion = toHex(reader.read(4))
  if (messageVersion !== VERSION) {
    throw new Error(
      `Message version mismatch: Expected ${VERSION}, received ${messageVersion}`
    )
  }
  const sender = PublicKey.fromString(toHex(reader.read(33)))
  const expectedRecipientDER = toHex(reader.read(33))
  const actualRecipientDER = recipient
    .toPublicKey()
    .encode(true, 'hex') as string
  if (expectedRecipientDER !== actualRecipientDER) {
    throw new Error(
      `The encrypted message expects a recipient public key of ${expectedRecipientDER}, but the provided key is ${actualRecipientDER}`
    )
  }
  const keyID = toBase64(reader.read(32))
  const encrypted = reader.read(reader.bin.length - reader.pos)
  const invoiceNumber = `2-message encryption-${keyID}`
  const signingPriv = sender.deriveChild(recipient, invoiceNumber)
  const recipientPub = recipient.deriveChild(sender, invoiceNumber)
  const sharedSecret = signingPriv.deriveSharedSecret(recipientPub)
  const symmetricKey = new SymmetricKey(sharedSecret.encode(true).slice(1))
  return symmetricKey.decrypt(encrypted) as number[]
}

// sign tests

import { sign, verify } from '../../messages/SignedMessage'
import PrivateKey from '../../primitives/PrivateKey'

describe('SignedMessage', () => {
  it('Signs a message for a recipient', () => {
    const sender = new PrivateKey(15)
    const recipient = new PrivateKey(21)
    const recipientPub = recipient.toPublicKey()
    const message = [1, 2, 4, 8, 16, 32]
    const signature = sign(message, sender, recipientPub)
    const verified = verify(message, signature, recipient)
    expect(verified).toEqual(true)
  })
  it('Signs a message for anyone', () => {
    const sender = new PrivateKey(15)
    const message = [1, 2, 4, 8, 16, 32]
    const signature = sign(message, sender)
    const verified = verify(message, signature)
    expect(verified).toEqual(true)
  })
  it('Fails to verify a message with a wrong version', () => {
    const sender = new PrivateKey(15)
    const recipient = new PrivateKey(21)
    const recipientPub = recipient.toPublicKey()
    const message = [1, 2, 4, 8, 16, 32]
    const signature = sign(message, sender, recipientPub)
    signature[0] = 1
    expect(() => verify(message, signature, recipient)).toThrow(
      new Error(
        'Message version mismatch: Expected 42423301, received 01423301'
      )
    )
  })
  it('Fails to verify a message with no verifier when required', () => {
    const sender = new PrivateKey(15)
    const recipient = new PrivateKey(21)
    const recipientPub = recipient.toPublicKey()
    const message = [1, 2, 4, 8, 16, 32]
    const signature = sign(message, sender, recipientPub)
    expect(() => verify(message, signature)).toThrow(
      new Error(
        'This signature can only be verified with knowledge of a specific private key. The associated public key is: 02352bbf4a4cdd12564f93fa332ce333301d9ad40271f8107181340aef25be59d5'
      )
    )
  })
  it('Fails to verify a message with a wrong verifier', () => {
    const sender = new PrivateKey(15)
    const recipient = new PrivateKey(21)
    const wrongRecipient = new PrivateKey(22)
    const recipientPub = recipient.toPublicKey()
    const message = [1, 2, 4, 8, 16, 32]
    const signature = sign(message, sender, recipientPub)
    expect(() => verify(message, signature, wrongRecipient)).toThrow(
      new Error(
        'The recipient public key is 03421f5fc9a21065445c96fdb91c0c1e2f2431741c72713b4b99ddcb316f31e9fc but the signature requres the recipient to have public key 02352bbf4a4cdd12564f93fa332ce333301d9ad40271f8107181340aef25be59d5'
      )
    )
  })
})

// encrypt tests

import { encrypt, decrypt } from '../../messages/EncryptedMessage'
import PrivateKey from '../../primitives/PrivateKey'

describe('EncryptedMessage', () => {
  it('Encrypts a message for a recipient', () => {
    const sender = new PrivateKey(15)
    const recipient = new PrivateKey(21)
    const recipientPub = recipient.toPublicKey()
    const message = [1, 2, 4, 8, 16, 32]
    const encrypted = encrypt(message, sender, recipientPub)
    const decrypted = decrypt(encrypted, recipient)
    expect(decrypted).toEqual(message)
  })
  it('Encrypts a message for a recipient with rare key length', () => {
    const recipient = new PrivateKey(21)
    {
      // Rare length case... Leading zeros in key BigNumber array.
      const encrypted = [
        66, 66, 16, 51, 2, 215, 146, 77, 79, 125, 67, 234, 150, 90, 70, 90, 227,
        9, 95, 244, 17, 49, 229, 148, 111, 60, 133, 247, 158, 68, 173, 188, 248,
        226, 126, 8, 14, 2, 53, 43, 191, 74, 76, 221, 18, 86, 79, 147, 250, 51,
        44, 227, 51, 48, 29, 154, 212, 2, 113, 248, 16, 113, 129, 52, 10, 239,
        37, 190, 89, 213,

        75, 148, 8, 235, 104, 137, 80, 129, 55, 68, 182, 141, 118, 212, 215,
        121, 161, 107, 62, 247, 12, 172, 244, 170, 208, 37, 213, 198, 103, 118,
        75, 166, 166, 131, 191, 105, 48, 232, 101, 223, 255, 169, 176, 204, 126,
        249, 78, 178, 10, 51, 13, 163, 58, 232, 122, 111, 210, 218, 187, 247,
        164, 101, 207, 15, 37, 227, 108, 82, 70, 35, 5, 148, 18, 162, 120, 64,
        46, 40, 227, 197, 6, 112, 207, 200, 238, 81
      ]
      expect(() => decrypt(encrypted, recipient)).not.toThrow()
    }
  })
  it('Fails to decrypt a message with wrong version', () => {
    const sender = new PrivateKey(15)
    const recipient = new PrivateKey(21)
    const recipientPub = recipient.toPublicKey()
    const message = [1, 2, 4, 8, 16, 32]
    const encrypted = encrypt(message, sender, recipientPub)
    encrypted[0] = 1
    expect(() => decrypt(encrypted, recipient)).toThrow(
      new Error(
        'Message version mismatch: Expected 42421033, received 01421033'
      )
    )
  })
  it('Fails to decrypt a message with wrong recipient', () => {
    const sender = new PrivateKey(15)
    const recipient = new PrivateKey(21)
    const wrongRecipient = new PrivateKey(22)
    const recipientPub = recipient.toPublicKey()
    const message = [1, 2, 4, 8, 16, 32]
    const encrypted = encrypt(message, sender, recipientPub)
    expect(() => decrypt(encrypted, wrongRecipient)).toThrow(
      new Error(
        'The encrypted message expects a recipient public key of 02352bbf4a4cdd12564f93fa332ce333301d9ad40271f8107181340aef25be59d5, but the provided key is 03421f5fc9a21065445c96fdb91c0c1e2f2431741c72713b4b99ddcb316f31e9fc'
      )
    )
  })
})